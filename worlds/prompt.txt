Here is the interfaces for a small text based adventure game.
package interfaces

import "fmt"

type ItemInterface interface {
	Name() string
	Description() string
	Examine() string
}

type LocationInterface interface {
	Name() string
	Describe() string
	ListKnownItems() []ItemInterface
	TakeItemByName(WorldInterface, string) (ItemInterface, string)
	Go(world WorldInterface, name string) (bool, string, LocationInterface)
	UseItem(item ItemInterface, targetName string) (string, bool)
	ExamineItem(name string) string
	TalkTo(name string) string
}

type WorldInterface struct {
	Name             string
	StartingLocation LocationInterface
	CurrentLocation  LocationInterface
	Locations        map[string]LocationInterface
	Inventory        *Inventory
}

func (i WorldInterface) GetLocationByName(s string) LocationInterface {
	for _, loc := range i.Locations {
		if loc.Name() == s {
			return loc
		}
	}
	fmt.Printf("Location %s not found in world %s\n", s, i.Name)
	return nil
}


This game has an inventory system defined here:
package interfaces

type Inventory struct {
	Items []ItemInterface
}

func (i *Inventory) AddItem(item ItemInterface) {
	i.Items = append(i.Items, item)
}

func (i *Inventory) RemoveItem(name string) ItemInterface {
	for j, invItem := range i.Items {
		if invItem.Name() == name {
			i.Items = append(i.Items[:j], i.Items[j+1:]...)
			return invItem
		}
	}
	return nil
}

func (i *Inventory) ListItems() []ItemInterface {
	return i.Items
}

func (i *Inventory) HaveItem(name string) bool {
	for _, item := range i.Items {
		if item.Name() == name {
			return true
		}
	}
	return false
}


This is the world we have defined so far:
package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

func NewSimpleWorld(inventory *interfaces.Inventory) interfaces.WorldInterface {
	var firstDoorKey = FirstDoorKey{}
	var screwdriver = Screwdriver{}

	var start = LocationStartingRoom{
		items: []interfaces.ItemInterface{
			firstDoorKey,
		},
	}
	var besideHouse = &LocationBesideHouse{
		screwdriver: &screwdriver,
	}
	var caveMouth = LocationCaveMouth{}
	var forkedPath = LocationForkedPath{}
	var frontSteps = FrontSteps{}
	var overgrownGarden = LocationOvergrownGarden{}
	var shedExterior = LocationShedExterior{}
	var shedInterior = LocationShedInterior{
		sword: ItemOldSword{},
	}
	var woodsEntrance = LocationWoodsEntrance{}
	var GoblinCampLocation = &GoblinCamp{}
	var MushroomGroveLocation = &MushroomGrove{}
	var fallenTree = &LocationFallenTree{}
	var hiddenForestShrine = &LocationHiddenForestShrine{}
	var ravineEdge = &LocationRavineEdge{}
	var sapTreeClearing = &LocationSapTreeClearing{}

	return interfaces.WorldInterface{
		Name:             "Small Example WorldInterface",
		StartingLocation: &start,
		CurrentLocation:  &start,

		Locations: map[string]interfaces.LocationInterface{
			start.Name():                 &start,
			besideHouse.Name():           besideHouse,
			caveMouth.Name():             caveMouth,
			forkedPath.Name():            forkedPath,
			frontSteps.Name():            frontSteps,
			overgrownGarden.Name():       &overgrownGarden,
			shedExterior.Name():          &shedExterior,
			shedInterior.Name():          &shedInterior,
			woodsEntrance.Name():         woodsEntrance,
			GoblinCampLocation.Name():    GoblinCampLocation,
			MushroomGroveLocation.Name(): MushroomGroveLocation,
			fallenTree.Name():            fallenTree,
			hiddenForestShrine.Name():    hiddenForestShrine,
			ravineEdge.Name():            ravineEdge,
			sapTreeClearing.Name():       sapTreeClearing,
		},
		Inventory: inventory,
	}
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

var LocationNameHiddenForestShrine = "Hidden Forest Shrine"

type LocationHiddenForestShrine struct{}

func (l *LocationHiddenForestShrine) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (l *LocationHiddenForestShrine) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (l *LocationHiddenForestShrine) Name() string { return LocationNameHiddenForestShrine }

func (l *LocationHiddenForestShrine) Describe() string {
	return `You step into a glade filled with shimmering light. 
A stone shrine rises from the forest floor, vines curling gently around its base.
Crystals float silently in the air, casting soft rainbow glows on the surrounding trees.
A hush falls over everything — the wind, the birds, even your own thoughts.
	
On the pedestal, faint glowing runes pulse gently. They seem to respond to your presence.

A voice, warm and ancient, echoes in your mind:
"You have taken your first step, young traveler. The forest remembers those who are kind and clever."

You feel a path opening before you — not one you can see, but one you will choose.`
}

func (l *LocationHiddenForestShrine) ListKnownItems() []interfaces.ItemInterface { return nil }

func (l *LocationHiddenForestShrine) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	return nil, "There is nothing to take here — only serenity."
}

func (l *LocationHiddenForestShrine) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "You kneel at the shrine. It hums softly in response.", true
}

func (l *LocationHiddenForestShrine) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	if dir == "up" {
		return true, "You climb back up the repaired ladder.", world.GetLocationByName("Ravine Edge")
	}
	return false, "Only trees surround you.", nil
}

package simple_example

import (
	"fmt"
	"github.com/veilstream/psql-text-based-adventure/core/interfaces"
)

type GlowingMushroom struct{}

func (g GlowingMushroom) Name() string        { return "glowing mushroom" }
func (g GlowingMushroom) Description() string { return "It glows with a soft, magical light." }
func (m GlowingMushroom) Examine() string {
	return "You look closely at the glowing mushroom. It pulses gently like it’s alive."
}

type MushroomGrove struct {
	mushroomTaken bool
}

func (m *MushroomGrove) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (m *MushroomGrove) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

var LocationNameMushroomGrove = "Mushroom Grove"

func (m *MushroomGrove) Name() string { return LocationNameMushroomGrove }

func (m *MushroomGrove) Describe() string {
	return "Mushrooms of all shapes and sizes glow gently. The air is peaceful here."
}

func (m *MushroomGrove) ListKnownItems() []interfaces.ItemInterface {
	var items []interfaces.ItemInterface
	if !m.mushroomTaken {
		items = append(items, GlowingMushroom{})
	}
	return items
}

func (m *MushroomGrove) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	if name == "glowing mushroom" && !m.mushroomTaken {
		m.mushroomTaken = true
		return GlowingMushroom{}, "You pick a glowing mushroom."
	}
	return nil, "You can't take that."
}

func (m *MushroomGrove) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "You can't use that here.", true
}

func (m *MushroomGrove) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	if dir == "north" {
		return true, "You return to the goblin camp.", world.GetLocationByName("Goblin Camp")
	}
	if dir == "west" {
		return true, "You head into a cavern glittering with crystals.", nil
	}
	return false, "You can't go that way.", nil
}

func (g *GoblinCamp) Examine(name string) string {
	if name == "goblin" {
		return "The goblin is small, green, and surprisingly tidy. He looks up hopefully at your satchel."
	}
	return fmt.Sprintf("You don't notice anything special about the %s.", name)
}

func (g *GoblinCamp) TalkTo(name string) string {
	if name == "goblin" {
		if g.helped {
			return "The goblin grins. 'Thanks again, friend!'", true
		}
		return "The goblin grumbles. 'Glowy... need glowy mushroom...'", true
	}
	return "", false
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

var LocationNameForkedPath = "Forked Path"

type LocationForkedPath struct{}

func (l LocationForkedPath) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (l LocationForkedPath) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (l LocationForkedPath) Name() string { return LocationNameForkedPath }

func (l LocationForkedPath) Describe() string {
	return "The path splits here: to the east stands a decrepit wooden shed; to the west a tangle of ivy hides a small garden clearing."
}

func (l LocationForkedPath) ListKnownItems() []interfaces.ItemInterface { return nil }
func (l LocationForkedPath) TakeItemByName(interfaces.WorldInterface, string) (interfaces.ItemInterface, string) {
	return nil, "There is nothing to take here."
}

func (l LocationForkedPath) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	switch dir {
	case "south":
		return true, "You retrace your steps toward the house.", world.GetLocationByName("Woods Entrance")
	case "east":
		return true, "You step toward the listing shed.", world.GetLocationByName("Shed Exterior")
	case "west":
		return true, "You push through the undergrowth toward the garden.", world.GetLocationByName("Overgrown Garden")
	default:
		return false, "That direction leads nowhere discernible.", nil
	}
}

func (l LocationForkedPath) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "That achieves nothing here.", true
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

var LocationNameWoodsEntrance = "Woods Entrance"

type LocationWoodsEntrance struct{}

func (w LocationWoodsEntrance) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (w LocationWoodsEntrance) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (w LocationWoodsEntrance) Name() string { return LocationNameWoodsEntrance }

func (w LocationWoodsEntrance) Describe() string {
	return "Tall firs loom ahead, their branches choking out the moonlight. A narrow path disappears into the darkness to the north. To the south, the house is visible."
}

func (w LocationWoodsEntrance) ListKnownItems() []interfaces.ItemInterface { return nil }
func (w LocationWoodsEntrance) TakeItemByName(interfaces.WorldInterface, string) (interfaces.ItemInterface, string) {
	return nil, "There is nothing to take."
}

func (w LocationWoodsEntrance) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	switch dir {
	case "south":
		return true, "You head back to the front steps.", world.GetLocationByName("Front Steps")
	case "north":
		// The engine should enforce the player has a lantern; we allow for now.
		return true, "You follow the dark path deeper into the woods.", world.GetLocationByName("Forked Path")
	default:
		return false, "You can't go that way.", nil
	}
}

func (w LocationWoodsEntrance) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "There's nothing here that responds to that item.", true
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

var LocationNameCaveMouth = "Cave Mouth"

type LocationCaveMouth struct{}

func (c LocationCaveMouth) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (c LocationCaveMouth) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (c LocationCaveMouth) Name() string { return LocationNameCaveMouth }
func (c LocationCaveMouth) Describe() string {
	return "A yawning cave entrance leads into impenetrable darkness. A chill wind whistles from the depths. up to the garden, east to the go deeper into the darkness."
}

func (c LocationCaveMouth) ListKnownItems() []interfaces.ItemInterface { return nil }
func (c LocationCaveMouth) TakeItemByName(interfaces.WorldInterface, string) (interfaces.ItemInterface, string) {
	return nil, "Nothing here to take."
}

func (c LocationCaveMouth) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	switch dir {
	case "up":
		return true, "You climb back up to the garden.", world.GetLocationByName("Overgrown Garden")
	case "east":
		return true, "You peer into the depths, and venture forward.", world.GetLocationByName("Goblin Camp")
	default:
		return false, "You can't go that way.", nil
	}
}

func (c LocationCaveMouth) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "Nothing happens.", true
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

var LocationNameOvergrownGarden = "Overgrown Garden"

type LocationOvergrownGarden struct {
	vinesCut bool
}

func (g *LocationOvergrownGarden) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (g *LocationOvergrownGarden) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (g *LocationOvergrownGarden) Name() string { return LocationNameOvergrownGarden }

func (g *LocationOvergrownGarden) Describe() string {
	if g.vinesCut {
		return "An old stone plinth stands cleared of vines. Its lid lies ajar, revealing a stairway descending into darkness."
	}
	return "Broken fountains and knee high ivy choke the clearing. Thick vines coil around a waist high stone plinth at the center."
}

func (g *LocationOvergrownGarden) ListKnownItems() []interfaces.ItemInterface { return nil }
func (g *LocationOvergrownGarden) TakeItemByName(interfaces.WorldInterface, string) (interfaces.ItemInterface, string) {
	return nil, "There's nothing here to pick up."
}

func (g *LocationOvergrownGarden) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	if item.Name() == "old sword" && target == "vines" && !g.vinesCut {
		g.vinesCut = true
		return "You hack through the vines, clearing the plinth and revealing a hidden stairway leading down.", true
	}
	return "That doesn't work.", true
}

func (g *LocationOvergrownGarden) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	switch dir {
	case "east":
		return true, "You return to the fork in the path.", world.GetLocationByName("Forked Path")
	case "down":
		if g.vinesCut {
			return true, "You descend the narrow stone steps.", world.GetLocationByName("Cave Mouth")
		}
		return false, "Thick vines block any passage downward.", nil
	default:
		return false, "Shrubs and trees block your path.", nil
	}
}

package simple_example

import (
	"fmt"
	"github.com/veilstream/psql-text-based-adventure/core/interfaces"
)

type FirstDoorKey struct {
}

func (f FirstDoorKey) Name() string {
	return "key"
}

func (f FirstDoorKey) Description() string {
	return "This is a key to a door."
}

var LocationNameStarting = "Starting Location"

type LocationStartingRoom struct {
	items        []interfaces.ItemInterface
	doorUnlocked bool
}

func (l *LocationStartingRoom) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (l *LocationStartingRoom) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (l *LocationStartingRoom) UseItem(item interfaces.ItemInterface, targetName string) (string, bool) {
	if item.Name() == "key" && targetName == "door" {
		l.doorUnlocked = true
		return "You unlock the door with the key. The key breaks in the lock, but you manage to open the door before it does.", false
	}
	return "You can't use that item on that target.", true
}

func (l *LocationStartingRoom) Go(world interfaces.WorldInterface, name string) (bool, string, interfaces.LocationInterface) {
	if name == "north" {
		if l.doorUnlocked {
			return true, "You go through the door to the north.", world.GetLocationByName("Front Steps")
		}
		return false, "The door is locked.", nil
	}
	if name == "south" {
		return true, "You are in a room, there is no way to go south.", nil
	}
	if name == "east" {
		return true, "You are in a room, there is no way to go east.", nil
	}
	if name == "west" {
		return true, "You are in a room, there is no way to go west.", nil
	}
	return false, "You can't go that way.", nil
}

func (l *LocationStartingRoom) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	for i, item := range l.items {
		if item.Name() == name {
			takenItem := l.items[i]
			l.items = append(l.items[:i], l.items[i+1:]...)
			return takenItem, "You take the " + name + "."
		}
	}
	return nil, "You can't take that item."
}

func (l *LocationStartingRoom) ListKnownItems() []interfaces.ItemInterface {
	return l.items
}

func (l *LocationStartingRoom) Name() string {
	return LocationNameStarting
}
func (l *LocationStartingRoom) Describe() string {
	s := "You are in a small room with a door to the north."

	if len(l.ListKnownItems()) > 0 {
		s += "\nYou see the following items:"
		for _, item := range l.ListKnownItems() {
			s = fmt.Sprintf("%s %s", s, item.Name())
		}
	}
	return s
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

type LogPile struct{}

func (l LogPile) Examine() string {
	//TODO implement me
	panic("implement me")
}

func (l LogPile) Name() string        { return "log pile" }
func (l LogPile) Description() string { return "A neatly stacked pile of firewood beside the house." }

type Screwdriver struct{}

func (s Screwdriver) Examine() string {
	//TODO implement me
	panic("implement me")
}

func (s Screwdriver) Name() string        { return "screwdriver" }
func (s Screwdriver) Description() string { return "A flathead screwdriver, a bit rusty but usable." }

var logPile = LogPile{}

var LocationNameBesideHouse = "Beside House"

type LocationBesideHouse struct {
	takenScrewdriver bool
	screwdriver      *Screwdriver
}

func (l *LocationBesideHouse) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (l *LocationBesideHouse) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (l *LocationBesideHouse) Name() string {
	return LocationNameBesideHouse
}

func (l *LocationBesideHouse) Describe() string {
	desc := "You are standing beside the house. There is a log pile stacked against the wall."
	if !l.takenScrewdriver {
		desc += " A screwdriver lies on top of the pile."
	}
	return desc
}

func (l *LocationBesideHouse) ListKnownItems() []interfaces.ItemInterface {
	items := []interfaces.ItemInterface{logPile}
	if !l.takenScrewdriver {
		items = append(items, l.screwdriver)
	}
	return items
}

func (l *LocationBesideHouse) TakeItemByName(w interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	if name == "log pile" {
		return nil, "The log pile is too heavy to take."
	}
	if name == "screwdriver" && !l.takenScrewdriver {
		l.takenScrewdriver = true
		return l.screwdriver, "You take the screwdriver."
	}
	return nil, "You can't take that item."
}

func (l *LocationBesideHouse) Go(world interfaces.WorldInterface, direction string) (bool, string, interfaces.LocationInterface) {
	if direction == "west" {
		return true, "You go back to the front steps.", world.GetLocationByName("Front Steps")
	}
	return false, "You can't go that way.", nil
}

func (l *LocationBesideHouse) UseItem(item interfaces.ItemInterface, targetName string) (string, bool) {
	return "You can't use that item here.", true
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

type WoodenPlank struct{}

func (p WoodenPlank) Examine() string {
	//TODO implement me
	panic("implement me")
}

func (p WoodenPlank) Name() string { return "wooden plank" }
func (p WoodenPlank) Description() string {
	return "A long, flat plank — perfect for patching something."
}

var LocationNameFallenTree = "Fallen Tree"

type LocationFallenTree struct {
	plankTaken bool
}

func (l *LocationFallenTree) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (l *LocationFallenTree) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (l *LocationFallenTree) Name() string { return LocationNameFallenTree }

func (l *LocationFallenTree) Describe() string {
	if l.plankTaken {
		return "A mossy fallen tree lies split and broken."
	}
	return "A mossy fallen tree blocks part of the path. One of its planks is loose and looks usable."
}

func (l *LocationFallenTree) ListKnownItems() []interfaces.ItemInterface {
	if !l.plankTaken {
		return []interfaces.ItemInterface{WoodenPlank{}}
	}
	return nil
}

func (l *LocationFallenTree) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	if name == "wooden plank" && !l.plankTaken {
		l.plankTaken = true
		return WoodenPlank{}, "You pry a plank loose from the tree trunk."
	}
	return nil, "You can't take that."
}

func (l *LocationFallenTree) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "Nothing happens.", true
}

func (l *LocationFallenTree) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	if dir == "east" {
		return true, "You walk back toward the mushroom grove.", world.GetLocationByName("Mushroom Grove")
	}
	return false, "There’s too much brush that way.", nil
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

type ItemLantern struct {
	attached bool
}

func (i ItemLantern) Examine() string {
	//TODO implement me
	panic("implement me")
}

func (i ItemLantern) Name() string {
	return "lantern"
}

func (i ItemLantern) Description() string {
	if i.attached {
		return "A small lantern, it is hanging on the wall beside the door. It is casting a small radius of light around you."
	}
	return "a small lantern"
}

func (i ItemLantern) Use(target interfaces.ItemInterface) string {
	return "You can't use that item on that target."
}

type FrontSteps struct {
}

func (f FrontSteps) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (f FrontSteps) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

var lantern = ItemLantern{attached: true}

func (f FrontSteps) Name() string {
	return "Front Steps"
}

func (f FrontSteps) Describe() string {
	return "You are standing on the front steps of a small house. It's dark out, the moon is obscured by clouds, " +
		"and the wind is howling. You can hear the sound of wind in the trees.\n" +
		"There's a small radius of light around you, it is cast by a lantern hanging on the wall beside the door. \n" +
		"You can see a small path leading away from the house.\n" +
		"To the north, you can see a small path leading into the woods.\n" +
		"To the south, behind you, there is the door you just exited.\n" +
		"To the east, you can see a small path leading to the back of the house.\n" +
		"To the west, darkness."
}

func (f FrontSteps) ListKnownItems() []interfaces.ItemInterface {
	return []interfaces.ItemInterface{
		lantern,
	}
}

func (f FrontSteps) TakeItemByName(world interfaces.WorldInterface, s string) (interfaces.ItemInterface, string) {
	if s == "lantern" && lantern.attached {
		return nil, "you can't remove it, it's attached to the wall."
	}
	if s == "lantern" {
		lantern.attached = false
		return lantern, "You take the lantern."
	}
	return nil, "You can't take that item."
}

func (f FrontSteps) Go(world interfaces.WorldInterface, name string) (bool, string, interfaces.LocationInterface) {
	if name == "north" {
		if world.Inventory.HaveItem("lantern") {
			return true, "You walk into the woods, the path is dark but you can see a little bit ahead of you.", world.GetLocationByName("Woods Entrance")
		}
		return false, "You take a few steps, and realise you will get lost without a light. you go back to the house.", nil
	}
	if name == "south" {
		return true, "You walk to the front door of the house.", world.GetLocationByName("Starting Location")
	}
	if name == "east" {
		return true, "You walk to the back of the house.", world.Locations["Beside House"]
	}
	if name == "west" {
		return false, "You get a bad feeling about this place, and decide to turn back.", nil
	}
	return false, "You can't go that way.", nil
}

func (f FrontSteps) UseItem(item interfaces.ItemInterface, targetName string) (string, bool) {
	if item.Name() == "screwdriver" && targetName == "lantern" {
		if lantern.attached {
			lantern.attached = false
			return "You use the screwdriver to remove the lantern from the sconce. The lantern is now loosely hanging from the wall.", true
		}
	}
	return "You can't use that item on that target.", true
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

var LocationNameRavineEdge = "Ravine Edge"

type LocationRavineEdge struct {
	ladderFixed bool
	inventory   *interfaces.Inventory
}

func (r *LocationRavineEdge) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (r *LocationRavineEdge) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (r *LocationRavineEdge) Name() string { return LocationNameRavineEdge }

func (r *LocationRavineEdge) Describe() string {
	if r.ladderFixed {
		return "A repaired ladder now spans the ravine, leading down safely."
	}
	return "You reach a ravine. A broken ladder lies splintered nearby. It's too dangerous to climb without fixing it."
}

func (r *LocationRavineEdge) ListKnownItems() []interfaces.ItemInterface {
	return nil
}

func (r *LocationRavineEdge) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	return nil, "There’s nothing to take."
}

func (r *LocationRavineEdge) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	if item.Name() == "wooden plank" && target == "ladder" && !r.ladderFixed {
		if r.inventory.HaveItem("sticky sap") {
			r.ladderFixed = true
			return "You patch the broken ladder with the plank and seal it with sticky sap.", true
		}
		return "You need something to hold the plank in place.", true
	}
	return "That doesn't work here.", true
}

func (r *LocationRavineEdge) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	if dir == "north" {
		return true, "You head back to the mushroom grove.", world.GetLocationByName("Mushroom Grove")
	}
	if dir == "down" {
		if r.ladderFixed {
			return true, "You carefully descend the ladder into the ravine.", world.GetLocationByName("Hidden Forest Shrine")
		}
		return false, "The ladder is broken — it's too dangerous to climb down.", nil
	}
	return false, "You can't go that way.", nil
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

var LocationNameShedExterior = "Shed Exterior"

type LocationShedExterior struct {
	hingeRemoved bool
}

func (s *LocationShedExterior) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (s *LocationShedExterior) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (s *LocationShedExterior) Name() string { return LocationNameShedExterior }

func (s *LocationShedExterior) Describe() string {
	desc := "A dilapidated wooden shed leans at odd angles. The door is secured by a single rusty hinge plate."
	if s.hingeRemoved {
		desc = "The shed door hangs loose on one side; you could easily slip inside."
	}
	return desc
}

func (s *LocationShedExterior) ListKnownItems() []interfaces.ItemInterface { return nil }
func (s *LocationShedExterior) TakeItemByName(interfaces.WorldInterface, string) (interfaces.ItemInterface, string) {
	return nil, "There's nothing here worth taking."
}

func (s *LocationShedExterior) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	if item.Name() == "screwdriver" && target == "hinge" && !s.hingeRemoved {
		s.hingeRemoved = true
		return "You pry off the rusty hinge plate—the door creaks open a crack.", true
	}
	return "That doesn't seem to work.", true
}

func (s *LocationShedExterior) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	switch dir {
	case "west":
		return true, "You head back to the fork.", world.GetLocationByName("Forked Path")
	case "in":
		if s.hingeRemoved {
			return true, "You slip into the dark shed interior.", world.GetLocationByName("Shed Interior")
		}
		return false, "The door won't budge; the hinge is still holding.", nil
	default:
		return false, "You can't go that way.", nil
	}
}

package simple_example

import "github.com/veilstream/psql-text-based-adventure/core/interfaces"

type StickySap struct{}

func (s StickySap) Examine() string {
	//TODO implement me
	panic("implement me")
}

func (s StickySap) Name() string { return "sticky sap" }
func (s StickySap) Description() string {
	return "A thick, sticky sap that could glue things together."
}

var LocationNameSapTreeClearing = "Sap Tree Clearing"

type LocationSapTreeClearing struct {
	sapTaken bool
}

func (l *LocationSapTreeClearing) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (l *LocationSapTreeClearing) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (l *LocationSapTreeClearing) Name() string { return LocationNameSapTreeClearing }

func (l *LocationSapTreeClearing) Describe() string {
	if l.sapTaken {
		return "A tall tree oozes dried sap. The clearing smells sweet."
	}
	return "A tall tree oozes thick, amber-colored sap. It drips slowly onto a flat rock."
}

func (l *LocationSapTreeClearing) ListKnownItems() []interfaces.ItemInterface {
	if !l.sapTaken {
		return []interfaces.ItemInterface{StickySap{}}
	}
	return nil
}

func (l *LocationSapTreeClearing) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	if name == "sticky sap" && !l.sapTaken {
		l.sapTaken = true
		return StickySap{}, "You collect some sticky sap in a small container."
	}
	return nil, "You can't take that."
}

func (l *LocationSapTreeClearing) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "That doesn’t seem to do anything here.", true
}

func (l *LocationSapTreeClearing) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	if dir == "west" {
		return true, "You head back toward the mushroom grove.", world.GetLocationByName("Mushroom Grove")
	}
	return false, "You can't go that way.", nil
}

package simple_example

import (
	"github.com/veilstream/psql-text-based-adventure/core/interfaces"
)

type CrystalShard struct{}

func (c CrystalShard) Examine() string {
	//TODO implement me
	panic("implement me")
}

func (c CrystalShard) Name() string        { return "Crystal Shard" }
func (c CrystalShard) Description() string { return "A shiny crystal shard that sparkles faintly." }

type GoblinCamp struct {
	tookShard    bool
	helped       bool
	goblinRanOff bool
}

var LocationNameGoblinCamp = "Goblin Camp"

func (g *GoblinCamp) Name() string { return LocationNameGoblinCamp }

func (g *GoblinCamp) Describe() string {
	directionsDescription := "\nYou can see a path leading south deeper into the cave, and a path leading west back to the cave mouth."
	if g.goblinRanOff {
		return "The goblin has run off, leaving his stew behind. The camp is now empty." + directionsDescription
	}
	if !g.helped {
		return "A small goblin stirs a pot and looks up at you. He seems hungry and mutters something about glowing mushrooms." + directionsDescription
	}
	if g.helped && !g.tookShard {
		return "The goblin smiles happily, stirring his now glowing stew. He left a crystal shard nearby." + directionsDescription
	}
	return "The goblin is busy stirring his stew. He seems happy and content." + directionsDescription
}

func (g *GoblinCamp) ListKnownItems() []interfaces.ItemInterface {
	if g.helped && !g.tookShard {
		return []interfaces.ItemInterface{CrystalShard{}}
	}
	return nil
}

func (g *GoblinCamp) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	if name == "crystal shard" && g.helped && !g.tookShard {
		g.tookShard = true
		return CrystalShard{}, "You take the crystal shard the goblin left for you."
	}
	return nil, "You can't take that."
}

func (g *GoblinCamp) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	if item.Name() == "mushroom" && !g.helped && target == "goblin" {
		g.helped = true
		return "The goblin gobbles the mushroom and grins. He tosses you a shiny shard from his satchel!", false
	}
	if item.Name() == "old sword" && target == "goblin" {
		return "The goblin looks at you in horror and runs away, leaving his stew behind.", true
	}
	if item.Name() == "old sword" && target == "stew" {
		return "You dip your sword in the stew, nothing happens.", true
	}

	bowl, ok := item.(ItemBowl)
	if ok && target == "stew" {
		if bowl.Full {
			return "You cannot do that with a full bowl.", true
		}
		if !g.goblinRanOff {
			return "The goblin swats your hand away. He looks annoyed.", true
		}
		bowl.Full = true
		bowl.Contents = "stew"
		return "You fill the bowl with stew.", true
	}

	return "That doesn't do anything here.", true
}

func (g *GoblinCamp) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	if dir == "south" {
		return true, "You head south to the mushroom grove.", world.GetLocationByName("Mushroom Grove")
	}
	if dir == "west" {
		return true, "You go back to the cave mouth.", world.GetLocationByName("Cave Mouth")
	}
	return false, "You can't go that way.", nil
}

package simple_example

import (
	"fmt"
	"github.com/veilstream/psql-text-based-adventure/core/interfaces"
)

var LocationNameShedInterior = "Shed Interior"

type ItemOldSword struct{}

func (i ItemOldSword) Name() string { return "old sword" }
func (i ItemOldSword) Description() string {
	return "A heavy, time‑worn longsword. Its edge is still sharp enough to hack through thick vines."
}

type ItemBowl struct {
	Full     bool
	Contents string
}

func (b ItemBowl) Name() string {
	if b.Full {
		return "bowl full of " + b.Contents
	}
	return "an empty bowl"
}

func (b ItemBowl) Description() string {
	if b.Full {
		return fmt.Sprintf("Bowl full of %s", b.Contents)
	}

	return fmt.Sprintf("A bowl, it looks like it could hold something. Probably %s.", b.Contents)
}

type LocationShedInterior struct {
	sword      ItemOldSword
	bowl       ItemBowl
	swordTaken bool
	bowlTaken  bool
}

func (l *LocationShedInterior) Examine(name string) string {
	//TODO implement me
	panic("implement me")
}

func (l *LocationShedInterior) TalkTo(name string) string {
	return "there is nobody to talk to here"
}

func (l *LocationShedInterior) Name() string { return LocationNameShedInterior }

func (l *LocationShedInterior) Describe() string {
	desc := "Dust motes dance in the lantern light. Cobwebbed tools line the walls."
	if !l.swordTaken {
		desc += " A long, cloth‑wrapped object rests on a rack."
	}
	if l.bowlTaken {
		desc += " A bowl lies on the floor, empty."
	}
	return desc
}

func (l *LocationShedInterior) ListKnownItems() []interfaces.ItemInterface {

	var oldSword = ItemOldSword{}

	if l.swordTaken {
		return nil
	}
	return []interfaces.ItemInterface{oldSword}
}

func (l *LocationShedInterior) TakeItemByName(world interfaces.WorldInterface, name string) (interfaces.ItemInterface, string) {
	if name == "bowl" {
		return &l.bowl, "You take empty the bowl."
	}

	if name == "cloth" && !l.swordTaken {
		l.swordTaken = true
		return l.sword, "You unwrap the bundle, as you do it falls apart in your hands revealing an old sword. You take the sword."
	}
	if name == "old sword" && !l.swordTaken {
		l.swordTaken = true
		return l.sword, "You unwrap the bundle, revealing an old sword."
	}
	return nil, "You can't take that."
}

func (l *LocationShedInterior) Go(world interfaces.WorldInterface, dir string) (bool, string, interfaces.LocationInterface) {
	switch dir {
	case "out":
		return true, "You step back outside.", world.GetLocationByName("Shed Exterior")
	default:
		return false, "You bump into a wall.", nil
	}
}

func (l *LocationShedInterior) UseItem(item interfaces.ItemInterface, target string) (string, bool) {
	return "No useful interaction here.", true
}





Given this information, and the fact we're designing this game for a 7yr old, what should we do next?
